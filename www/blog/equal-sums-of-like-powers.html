<!DOCTYPE html>
<html lang="ru"><head>
  <title>Равные суммы одинаковых степеней</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="description" content="">
  <meta name="keywords" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" type="text/css" href="/css/default.css">
  <link rel="canonical" href="https://dmaslov.me/blog/equal-sums-of-like-powers.html">
  <script defer src="/js/blognav.js"></script>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-B65M23L0K6"></script>
  <script>
	window.dataLayer = window.dataLayer || [];
	function gtag() { dataLayer.push(arguments); }
	gtag('js', new Date());
	gtag('config', 'G-B65M23L0K6');
	if (window.location.hostname === 'localhost')
	  window['ga-disable-G-B65M23L0K6'] = true;
  </script>
</head>
<body onload="setPostLinks()">

<!-- Navigation bar -->
<script src="/js/pageheader.js"></script>

<!-- Title, tags, date -->

<h1 class="blogpost">Равные суммы одинаковых степеней<br>
  Equal sums of like powers</h1>

<!-- Navigation links -->
<script>insertTopLinks()</script>

<!-- Content -->

<!-- Это временный контент - нужно доработать -->

<p class="column text">
  Эта статья расширяет серию коротких постов в блоге о челлендеже &laquo;Equal sums of like powers&raquo;. Если коротко, то я хочу найти минимальное решение для диофантова уравнения 4-й степени вида 4.1.4:
</p>

<div class="column txtcenter">
  A<sup>4</sup>&nbsp;=&nbsp;B<sup>4</sup>&nbsp;+&nbsp;C<sup>4</sup>&nbsp;+&nbsp;D<sup>4</sup>
</div>

<p class="column text">
  Здесь стоит добавить небольшое введение. Рассказать о том, что такое диофантовы уравнения. Рассказать о 10-й проблеме Гильберта. И о том, зачем мы пытаемся найти такие решения (опровержение так называемой гипотезы Euler quartic conjecture). А также о том, когда, кем и как было найдено это решение (сначала это был N. Elkies в 1987 году с его решением 20 615 673, а затем Roger Frye в 1988 с его наименьшим решением 422 481).
</p>

<p class="column text">
  Основная задача &mdash; написать универсальную программу, перебирающую все решения, оптимизировать её алгоритм и выяснить, за какое время будет найдено минимальное решение Фрая на современном процессоре Core i5-10400F, производя вычисления на всех 6 ядрах в 12 потоков.
</p>

<p class="column text">
  Я начну с наивного решения и буду шаг за шагом его улучшать, объясняя свои действия и приводя результаты этих улучшений. Измерение скорости работы программы будет выполняться на поиске решений для уравнения 4.1.4, так как его решения меньше и находятся значительно быстрее. Весь исходный код этого эксперимента расположен в основном репозитории проекта iLWN (проект Lab). Но здесь я буду использовать только Gists и только для основных частей кода программы.
</p>

<p class="column text">
  Для своего удобства я буду использовать библиотеку AML (класс файла, функции форматирования и работу с консолью). Но не буду давать дополнительных пояснений, так как думаю, что это будет интуитивно понятно. Исходный код библиотеки снабжён комментариями и находится в публичном репозитории, поэтому при желании можно будет разобраться самостоятельно.
</p>

<!-- Конец временного контента -->

<div class="column divider">&bull; &bull; &bull;</div>

<p class="column text">
  Итак, я начну с наивного решения. Для простоты буду использовать 64-битные переменные, что позволит проверить все возможные комбинации до значения старшего коэффициента 49,796 включительно (для уравнения 4.1.4). Программа будет последовательно перебирать все возможные варианты коэффициентов правой части, вычислять сумму их степеней и затем проверять, существует ли такой коэффициент для левой части, степень которого равна этой сумме.
</p>

<p class="column text">
  На мой взгляд, это очевидное и достаточно простое решение. Но чтобы делать меньше арифметических операций внутри цикла, сразу предлагаю простую оптимизацию: мы заранее вычислим нужные степени всех чисел от 1 до 49,796 и поместим их в массив. Сделаем это в отдельной функции <span class="codetext">CalcPowers()</span>:
</p>

<div class="column">
  <script src="https://gist.github.com/aloncat/a188e76357c26aedbcb5cf907e16cb51.js?file=calc-powers.cpp"></script>
</div>

<p class="column text">
  В основной функции мы сначала инициализируем массив со степенями, затем массив коэффициентов правой части уравнения. Все возможные значения левой части помещаем в <span class="codetext">std::map</span> для простоты проверки. Внутри основного цикла: считаем сумму степеней коэффициентов правой части уравнения, ищем полученное значение в <span class="codetext">std::map</span>. Если оно найдено, значит мы нашли решение. Далее выбираем следующий набор коэффициентов и повторяем цикл.
</p>

<p class="column text">
  Функция <span class="codetext">SearchForFactors()</span> принимает 3 параметра: степень уравнения (power), количество коэффициентов правой части (count) и значение старшего коэффициента (hiFactor), с которого начинается проверка. Вот код этой функции:
</p>

<div class="column">
  <script src="https://gist.github.com/aloncat/a188e76357c26aedbcb5cf907e16cb51.js?file=search-fn-v1.cpp"></script>
</div>

<p class="column text">
  Весь <a href="https://github.com/aloncat/ilwn/blob/f116e903f772af2bc31cc64dbd006bd13ff2af63/source/lab/diophantine.cpp" target="_blank">исходный код</a> программы (наивное решение, приведённое выше) находится в публичном репозитории <a href="https://github.com/aloncat/ilwn" target="_blank">проекта iLWN</a>. Финальная версия <a href="https://github.com/aloncat/ilwn/blob/master/source/lab/diophantine.cpp" target="_bank">находится здесь</a> (по этой ссылке также можно посмотреть всю историю изменений).
</p>

<p class="column text">
  Итак, у нас есть первая версия алгоритма! Запускаем и ждём результат: программе понадобилось примерно 150 секунд, чтобы найти первые 3 решения:
</p>

<div class="column">
  <pre class="output">Searching for factors (4.1.4)
Factor limit is set to 46340
Solution found: 353=315+272+120+30
Solution found: 651=599+430+340+240
Solution found: 706=630+544+240+60</pre>
</div>

<p class="column text">
  Оставим пока в стороне вопрос о скорости работы программы и обратим внимание на её вывод. На самом деле она нашла только два примитивных решения. В последней строке программа выдала первое решение, все коэффициенты которого просто умножены на 2. Нам необходимо фильтровать такие решения, так как они не представляют никакого интереса.
</p>

<div class="column divider">&bull; &bull; &bull;</div>

<p class="column text">
  Чтобы убрать из вывода программы непримитивные решения, нам понадобится функция <span class="codetext">GetPrimes()</span>, вычисляющая все простые числа до заданного. Используем простую реализацию решета Эратосфена (каждый бит массива <span class="codetext">bits</span> соответствует одному нечётному числу, начиная с 3):
</p>

<div class="column">
  <script src="https://gist.github.com/aloncat/a188e76357c26aedbcb5cf907e16cb51.js?file=get-primes.cpp"></script>
</div>

<p class="column text">
  Создадим структуру <span class="codetext">Solution</span>, в которой будем хранить решение:
</p>

<div class="column">
  <script src="https://gist.github.com/aloncat/a188e76357c26aedbcb5cf907e16cb51.js?file=solution-struct.cpp"></script>
</div>

<p class="column text">
  Также создадим класс контейнера <span class="codetext">Solutions</span>, в который будем добавлять все найденные решения:
</p>

<div class="column">
  <script src="https://gist.github.com/aloncat/a188e76357c26aedbcb5cf907e16cb51.js?file=solutions-container.cpp"></script>
</div>

<p class="column text">
  Проверку решения выполняет функция <span class="codetext">Solutions::IsPrimitive()</span>. В ней мы проверяем делимость каждого коэффициента решения на простые числа, не превышающие значения самого младшего коэффициента. Если мы сможем найти такое простое N, которое будет делить без остатка каждый коэффициент решения, то это будет означать, что решение не примитивное. Такое решение мы не будем добавлять в контейнер.
</p>

<p class="column text">
  Теперь проверка решения в главной функции выглядит так:
</p>

<div class="column">
  <script src="https://gist.github.com/aloncat/a188e76357c26aedbcb5cf907e16cb51.js?file=fn-v2-changes.cpp"></script>
</div>

<div class="column divider">&bull; &bull; &bull;</div>

<p class="column text">
  Вывод непримитивных решений мы отфильтровали. Однако, есть ещё одна, не совсем очевидная проблема. Лучше будет показать её на примере вывода для уравнения 3.1.3. Собираем новую версию программы и запускаем:
</p>

<div class="column">
  <pre class="output">Searching for factors (3.1.3)
Factor limit is set to 49999
Solution found: 6=5+4+3
Solution found: 9=8+6+1
Solution found: 20=17+14+7
Solution found: 19=18+10+3
Solution found: 28=21+19+18
Solution found: 25=22+17+4
Solution found: 29=27+15+11
Solution found: 41=33+32+6
Solution found: 46=37+30+27
Solution found: 46=37+36+3
Solution found: 41=40+17+2</pre>
</div>

<p class="column text">
  Непримитивные решения пропали из вывода. Но, как мы видим, сейчас программа считает &laquo;старшим&raquo; наибольший коэффициент в правой части. Тогда как на самом деле старший коэффициент уравнения &mdash; тот, что находится в его левой части. Из-за этого не только нарушается порядок вывода решений, но и могут быть пропущены некоторые из них, когда программа достигнет ограничения по максимальному значению старшего коэффициента.
</p>

<p class="column text">
  Чтобы добиться нужного поведения, нам необходимо перебирать левый коэффициент уравнения таким же способом, как и правые коэффициенты. При этом нам, видимо, придётся пока отказаться от использования <span class="codetext">std::map</span>, что должно привести к сильному замедлению работы. Позже, мы начнём оптимизировать алгоритм и улучшим эффективность. Сейчас же главное &mdash; добиться корректной работы программы.
</p>

<p class="column text">
  Пусть теперь <span class="codetext">k[0]</span> будет хранить коэффициент левой части уравнения. Тогда условие главного цикла изменится на <span class="codetext">while&nbsp;(k[0]&nbsp;&lt;=&nbsp;maxFactor)</span>, а проверка решения заменится условием <span class="codetext">if&nbsp;(sum&nbsp;==&nbsp;powers[k[0]])</span>. Вот полный код изменённой функции:
</p>

<div class="column">
  <script src="https://gist.github.com/aloncat/a188e76357c26aedbcb5cf907e16cb51.js?file=search-fn-v3.cpp"></script>
</div>

<p class="column text">
  Из-за внесённых изменений время работы программы для уравнения 4.1.4 увеличилось как минимум в несколько раз (см. подробности далее). Но теперь её вывод (для 3.1.3) выглядит так, как должен:
</p>

<div class="column">
  <pre class="output">Searching for factors (3.1.3)
Factor limit is set to 49999
Solution found: 6=5+4+3
Solution found: 9=8+6+1
Solution found: 19=18+10+3
Solution found: 20=17+14+7
Solution found: 25=22+17+4
Solution found: 28=21+19+18
Solution found: 29=27+15+11
Solution found: 41=33+32+6
Solution found: 41=40+17+2
Solution found: 44=41+23+16
Solution found: 46=37+30+27
Solution found: 46=37+36+3</pre>
</div>

<div class="column divider">&bull; &bull; &bull;</div>

<p class="column text">
  Программа работает корректно, хоть и очень медленно. Теперь можно приступать к оптимизации алгоритма. Но прежде, чем я начну, я хочу добавить вывод результатов в файл, заменить вызовы <span class="codetext">printf()</span> на <span class="codetext">aux::Printf()</span>, добавить периодический вывод прогресса и возможность прерывания работы программы. И конечно, нужно добавить вывод времени работы для того, чтобы можно было оценить влияние оптимизаций.
</p>

<p class="column text">
  Я не буду вставлять здесь получившийся код, так как он теперь стал значительно больше. Посмотреть содержимое файла <a href="https://github.com/aloncat/ilwn/blob/05f0f1d2929a452010ca475506fb68bf9e997a9b/source/lab/diophantine.cpp" target="_blank">можно тут</a>. Воспользовавшись кнопкой History (История) можно сравнить новую версию файла с предыдущей.
</p>

<div class="column divider">&bull; &bull; &bull;</div>

<p class="column text">
  Сейчас моя задача &mdash; ускорить работу программы. И первое, о чём стоит подумать, это о падении скорости после отказа от использования <span class="codetext">std::map</span>. Первая версия программы примерно за 150 секунд работы успела выдать 3 решения и дойти до старшего коэффициента 630. Новая же версия, проработав 10 минут, выдала лишь одно решение, добравшись только до значения 448. Так почему же это произошло?
</p>

<p class="column text">
  В первой версии мы перебирали только коэффициенты правой части, а в новой &mdash; все, то есть на 1 больше. Для уравнения 4.1.4, в котором всего 5 коэффициентов, при значении старшего коэффициента, равном 20, количество итераций основного цикла выросло в 5.75 раза, при коэффициенте 30 &mdash; в 8.25 раза, при 50 &mdash; в 13.25 раза, при 100 &mdash; в 25.75 раза! Легко заметить, что влияние дополнительного коэффициента нелинейно и тем сильнее, чем дальше поиск. Поэтому несмотря на то, что цикл стал проще &mdash; в нём теперь нет вызова <span class="codetext">std::map::find()</span>, &mdash; такое значительное увеличение количества итераций имеет крайне негативный эффект.
</p>

<p class="column text">
  Хорошая новость в том, что мы можем перебирать на один коэффициент меньше и при этом &laquo;искать&raquo; последний тем же методом, что и раньше. И для этого нам даже не будет нужен <span class="codetext">std::map</span>. Если мы вычтем из значения левой части уравнения степени каждого коэффициента правой части, кроме последнего, то полученное значение будет степенью последнего коэффициента. Всё, что нам останется сделать &mdash; найти такое целое число, степень которого была бы равна полученной разности. И если такое число существует, то вместе с остальными коэффициентами оно даст нам решение.
</p>

<p class="column text">
  Так как теперь в сумме степеней будет на одно слагаемое меньше, то в качестве бонуса мы также получим более высокое значение переменной <span class="codetext">hiFactor</span>. Максимальное значение старшего коэффициента (для уравнения 4.1.4) увеличится с 49,796 до 55,108!
</p>

<div class="column">
  <script src="https://gist.github.com/aloncat/a188e76357c26aedbcb5cf907e16cb51.js?file=fn-v4-changes-a.cpp"></script>
</div>

<p class="column text">
  Так как массив степеней упорядочен по возрастанию, мы можем использовать бинарный поиск, чтобы найти число по его степени. По сложности это и будет примерно соответствовать <span class="codetext">std::map::find()</span>. И так как коэффициенты решения должны располагаться в невозрастающем порядке, то искомое значение не будет превышать значения предпоследнего коэффициента, что сделает поиск ещё быстрее. И теперь начало основного цикла нашего алгоритма будет выглядеть следующим образом:
</p>

<div class="column">
  <script src="https://gist.github.com/aloncat/a188e76357c26aedbcb5cf907e16cb51.js?file=fn-v4-changes-b.cpp"></script>
</div>

<p class="column text">
  Новый оптимизированный алгоритм работает даже лучше, чем я ожидал. До значения старшего коэффициента, равного 700, на этот раз программа добралась всего за 101 секунду! Это примерно в 1.49 раза быстрее, чем исходный вариант с <span class="codetext">std::map</span> (который закончил работу даже раньше, ещё на значении 630)! И более, чем в 6 раз быстрее варианта, предшествующего оптимизации!
</p>

<div class="column divider">&bull; &bull; &bull;</div>

<!-- Navigation links -->
<script>insertBottomLinks()</script>

<!-- Footer -->
<div id="pageFooter" data-lang="ru" data-url-path="/blog/equal-sums-of-like-powers.html"></div>

<!-- Links to other posts -->
<script>
  function setPostLinks() {
	setPrevBlogPostUrl("");
	setNextBlogPostUrl("");
  }
</script>

</body>
</html>
