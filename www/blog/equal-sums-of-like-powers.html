<!DOCTYPE html>
<html lang="ru"><head>
  <title>Равные суммы одинаковых степеней</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="description" content="">
  <meta name="keywords" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" type="text/css" href="/css/default.css">
  <link rel="canonical" href="https://dmaslov.me/blog/equal-sums-of-like-powers.html">
  <script defer src="/js/blognav.js"></script>
  <!-- Google fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Math&display=swap" rel="stylesheet">
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-B65M23L0K6"></script>
  <script>
	window.dataLayer = window.dataLayer || [];
	function gtag() { dataLayer.push(arguments); }
	gtag('js', new Date());
	gtag('config', 'G-B65M23L0K6');
	if (window.location.hostname === 'localhost')
	  window['ga-disable-G-B65M23L0K6'] = true;
  </script>
</head>
<body onload="setPostLinks()">

<!-- Navigation bar -->
<script src="/js/pageheader.js"></script>

<!-- Title, tags, date -->

<h1 class="blogpost">Равные суммы одинаковых степеней<br>
  Equal sums of like powers</h1>

<!-- Navigation links -->
<script>insertTopLinks()</script>

<!-- Content -->

<!-- Это временный контент - нужно доработать -->
<center>===</center>

<p class="column text">
  Эта статья расширяет серию коротких постов в блоге о челлендеже &laquo;Equal sums of like powers&raquo;. Если коротко, то я хочу найти минимальное решение для диофантова уравнения 4-й степени вида 4.1.3:
</p>

<div class="column mathtext">
  z<sup>4</sup>&#8287;=&#8287;a<sup>4</sup>&#8287;+&#8287;b<sup>4</sup>&#8287;+&#8287;c<sup>4</sup>
</div>

<p class="column text">
  Здесь стоит добавить небольшое введение. Рассказать о том, что такое диофантовы уравнения. Рассказать о том, зачем мы пытаемся найти такие решения (опровержение так называемой гипотезы Euler quartic conjecture). А также о том, когда, кем и как было найдено это решение (сначала это был N. Elkies в 1987 году с его решением 20 615 673, а затем Roger Frye в 1988 с его наименьшим решением 422 481).
</p>

<p class="column text">
  Основная задача &mdash; написать универсальную программу (подходящую для любых уравнений вида p.1.n), перебирающую все решения, оптимизировать её алгоритм и выяснить, за какое время будет найдено минимальное решение Фрая на современном процессоре Core i5-10400F, производя вычисления на всех 6 ядрах в 12 потоков.
</p>

<p class="column text">
  Я начну с наивного решения и буду шаг за шагом его улучшать, объясняя свои действия и приводя результаты этих улучшений. Измерение скорости работы программы будет выполняться на поиске решений для уравнения 4.1.4, так как его решения меньше и находятся значительно быстрее. Весь исходный код этого эксперимента расположен в основном репозитории проекта iLWN (проект Lab). Но здесь я буду использовать только Gists и только для основных частей кода программы.
</p>

<p class="column text">
  Для своего удобства я буду использовать библиотеку AML (класс файла, функции форматирования и работу с консолью). Но не буду давать дополнительных пояснений, так как думаю, что это будет интуитивно понятно. Исходный код библиотеки снабжён комментариями и находится в публичном репозитории, поэтому при желании можно будет разобраться самостоятельно.
</p>

<center>===</center>
<!-- Конец временного контента -->

<div class="column divider">&bull; &bull; &bull;</div>

<p class="column text">
  Итак, я начну с наивного решения. Для простоты буду использовать 64-битные переменные, что позволит проверить все возможные комбинации до значения старшего коэффициента 49,796 включительно (для уравнения 4.1.3). Программа будет последовательно перебирать все возможные варианты коэффициентов правой части, вычислять сумму их степеней и затем проверять, существует ли такой коэффициент для левой части, степень которого равна этой сумме.
</p>

<p class="column text">
  На мой взгляд, это очевидное и достаточно простое решение. Но чтобы делать меньше арифметических операций внутри цикла, сразу предлагаю простую оптимизацию: мы заранее вычислим нужные степени всех чисел от 1 до 49,796 и поместим их в массив. Сделаем это в отдельной функции <span class="codetext">CalcPowers()</span>:
</p>

<div class="column">
  <script src="https://gist.github.com/aloncat/a188e76357c26aedbcb5cf907e16cb51.js?file=calc-powers.cpp"></script>
</div>

<p class="column text">
  В основной функции мы сначала инициализируем массив со степенями, затем массив коэффициентов правой части уравнения. Все возможные значения левой части помещаем в <span class="codetext">std::map</span> для простоты проверки. Внутри основного цикла: считаем сумму степеней коэффициентов правой части уравнения, ищем полученное значение в <span class="codetext">std::map</span>. Если оно найдено, значит мы нашли решение. Далее выбираем следующий набор коэффициентов и повторяем цикл.
</p>

<p class="column text">
  Функция <span class="codetext">SearchForFactors()</span> принимает 3 параметра: степень уравнения (power), количество коэффициентов правой части (count) и значение старшего коэффициента (hiFactor), с которого начинается проверка. Вот код этой функции:
</p>

<div class="column">
  <script src="https://gist.github.com/aloncat/a188e76357c26aedbcb5cf907e16cb51.js?file=search-fn-v1.cpp"></script>
</div>

<p class="column text">
  Весь <a href="https://github.com/aloncat/ilwn/blob/f116e903f772af2bc31cc64dbd006bd13ff2af63/source/lab/diophantine.cpp" target="_blank">исходный код</a> программы (наивное решение, приведённое выше) находится в публичном репозитории <a href="https://github.com/aloncat/ilwn" target="_blank">проекта iLWN</a>. Самая актуальная версия файла <a href="https://github.com/aloncat/ilwn/blob/master/source/lab/diophantine.cpp" target="_bank">находится здесь</a> (проект Lab). По последней ссылке также можно посмотреть всю историю изменений (но имейте ввиду, что там могут быть коммиты, сделанные уже после окончания работы над этим материалом).
</p>

<p class="column text">
  Итак, у нас есть первая версия алгоритма! Запускаем и ждём результат: программе понадобилось примерно 150 секунд, чтобы найти первые 3 решения:
</p>

<div class="column">
  <pre class="output">Searching for factors (4.1.4)
Factor limit is set to 46340
Solution found: 353=315+272+120+30
Solution found: 651=599+430+340+240
Solution found: 706=630+544+240+60</pre>
</div>

<p class="column text">
  Оставим пока в стороне вопрос о скорости работы программы и обратим внимание на её вывод. На самом деле она нашла только два примитивных решения. В последней строке программа выдала первое решение, все коэффициенты которого просто умножены на 2. Нам необходимо фильтровать такие решения, так как они не представляют никакого интереса.
</p>

<div class="column divider">&bull; &bull; &bull;</div>

<p class="column text">
  Чтобы убрать из вывода программы непримитивные решения, нам понадобится функция <span class="codetext">GetPrimes()</span>, вычисляющая все простые числа до заданного. Используем простую реализацию решета Эратосфена (каждый бит массива <span class="codetext">bits</span> соответствует одному нечётному числу, начиная с 3):
</p>

<div class="column">
  <script src="https://gist.github.com/aloncat/a188e76357c26aedbcb5cf907e16cb51.js?file=get-primes.cpp"></script>
</div>

<p class="column text">
  Создадим структуру <span class="codetext">Solution</span>, в которой будем хранить решение:
</p>

<div class="column">
  <script src="https://gist.github.com/aloncat/a188e76357c26aedbcb5cf907e16cb51.js?file=solution-struct.cpp"></script>
</div>

<p class="column text">
  Также создадим класс контейнера <span class="codetext">Solutions</span>, в который будем добавлять все найденные решения:
</p>

<div class="column">
  <script src="https://gist.github.com/aloncat/a188e76357c26aedbcb5cf907e16cb51.js?file=solutions-container.cpp"></script>
</div>

<p class="column text">
  Проверку решения выполняет функция <span class="codetext">Solutions::IsPrimitive()</span>. В ней мы проверяем делимость каждого коэффициента решения на простые числа, не превышающие значения самого младшего коэффициента. Если мы сможем найти такое простое N, которое будет делить без остатка каждый коэффициент решения, то это будет означать, что решение не примитивное. Такое решение мы не будем добавлять в контейнер.
</p>

<p class="column text">
  Теперь проверка решения в главной функции выглядит так:
</p>

<div class="column">
  <script src="https://gist.github.com/aloncat/a188e76357c26aedbcb5cf907e16cb51.js?file=fn-v2-changes.cpp"></script>
</div>

<div class="column divider">&bull; &bull; &bull;</div>

<p class="column text">
  Вывод непримитивных решений мы отфильтровали. Однако, есть ещё одна, не совсем очевидная проблема. Лучше будет показать её на примере вывода для уравнения 3.1.3. Собираем новую версию программы и запускаем:
</p>

<div class="column">
  <pre class="output">Searching for factors (3.1.3)
Factor limit is set to 49999
Solution found: 6=5+4+3
Solution found: 9=8+6+1
Solution found: 20=17+14+7
Solution found: 19=18+10+3
Solution found: 28=21+19+18
Solution found: 25=22+17+4
Solution found: 29=27+15+11
Solution found: 41=33+32+6
Solution found: 46=37+30+27
Solution found: 46=37+36+3
Solution found: 41=40+17+2</pre>
</div>

<p class="column text">
  Непримитивные решения пропали из вывода. Но, как мы видим, сейчас программа считает &laquo;старшим&raquo; наибольший коэффициент в правой части. Тогда как на самом деле старший коэффициент уравнения &mdash; тот, что находится в его левой части. Из-за этого не только нарушается порядок вывода решений, но и могут быть пропущены некоторые из них, когда программа достигнет ограничения по максимальному значению старшего коэффициента.
</p>

<p class="column text">
  Чтобы добиться нужного поведения, нам необходимо перебирать левый коэффициент уравнения таким же способом, как и правые коэффициенты. При этом нам, видимо, придётся пока отказаться от использования <span class="codetext">std::map</span>, что должно привести к сильному замедлению работы. Позже, мы начнём оптимизировать алгоритм и улучшим эффективность. Сейчас же главное &mdash; добиться корректной работы программы.
</p>

<p class="column text">
  Пусть теперь <span class="codetext">k[0]</span> будет хранить коэффициент левой части уравнения. Тогда условие главного цикла изменится на <span class="codetext">while&nbsp;(k[0]&nbsp;&lt;=&nbsp;maxFactor)</span>, а проверка решения заменится условием <span class="codetext">if&nbsp;(sum&nbsp;==&nbsp;powers[k[0]])</span>. Вот полный код изменённой функции:
</p>

<div class="column">
  <script src="https://gist.github.com/aloncat/a188e76357c26aedbcb5cf907e16cb51.js?file=search-fn-v3.cpp"></script>
</div>

<p class="column text">
  Из-за внесённых изменений время работы программы для уравнения 4.1.4 увеличилось как минимум в несколько раз (см. подробности далее). Но теперь её вывод (для 3.1.3) выглядит так, как должен:
</p>

<div class="column">
  <pre class="output">Searching for factors (3.1.3)
Factor limit is set to 49999
Solution found: 6=5+4+3
Solution found: 9=8+6+1
Solution found: 19=18+10+3
Solution found: 20=17+14+7
Solution found: 25=22+17+4
Solution found: 28=21+19+18
Solution found: 29=27+15+11
Solution found: 41=33+32+6
Solution found: 41=40+17+2
Solution found: 44=41+23+16
Solution found: 46=37+30+27
Solution found: 46=37+36+3</pre>
</div>

<div class="column divider">&bull; &bull; &bull;</div>

<p class="column text">
  Программа работает корректно, хоть и очень медленно. Теперь можно приступать к оптимизации алгоритма. Но прежде, чем я начну, я хочу добавить вывод результатов в файл, заменить вызовы <span class="codetext">printf()</span> на <span class="codetext">aux::Printf()</span>, добавить периодический вывод прогресса и возможность прерывания работы программы. И конечно, нужно добавить вывод времени работы для того, чтобы можно было оценить влияние оптимизаций.
</p>

<p class="column text">
  Я не буду вставлять здесь получившийся код, так как он теперь стал значительно больше. Посмотреть содержимое файла <a href="https://github.com/aloncat/ilwn/blob/05f0f1d2929a452010ca475506fb68bf9e997a9b/source/lab/diophantine.cpp" target="_blank">можно тут</a>. Воспользовавшись кнопкой History (История) можно сравнить новую версию файла с предыдущей.
</p>

<div class="column divider">&bull; &bull; &bull;</div>

<p class="column text">
  Теперь моя задача &mdash; ускорить работу программы. И первое, о чём стоит подумать, это о падении скорости после отказа от использования <span class="codetext">std::map</span>. Первая версия программы примерно за 150 секунд работы успела выдать 3 решения и дойти до старшего коэффициента 630. Новая же версия, проработав 10 минут, выдала лишь одно решение, добравшись только до значения 448. Так почему же это произошло?
</p>

<p class="column text">
  В первой версии мы перебирали только коэффициенты правой части, а в новой &mdash; все, то есть на 1 больше. Для уравнения 4.1.4, в котором всего 5 коэффициентов, при значении старшего коэффициента, равном 20, количество итераций основного цикла выросло в 5.75 раза, при коэффициенте 30 &mdash; в 8.25 раза, при 50 &mdash; в 13.25 раза, при 100 &mdash; в 25.75 раза! Легко заметить, что влияние дополнительного коэффициента нелинейно и тем сильнее, чем дальше поиск. Поэтому несмотря на то, что цикл стал проще &mdash; в нём теперь нет вызова <span class="codetext">std::map::find()</span>, &mdash; такое значительное увеличение количества итераций имеет крайне негативный эффект.
</p>

<p class="column text">
  Хорошая новость в том, что мы можем перебирать на один коэффициент меньше и при этом &laquo;искать&raquo; последний тем же методом, что и раньше. И для этого нам даже не будет нужен <span class="codetext">std::map</span>. Если мы вычтем из значения левой части уравнения степени каждого коэффициента правой части, кроме последнего, то полученное значение будет степенью последнего коэффициента. Всё, что нам останется сделать &mdash; найти такое целое число, степень которого была бы равна полученной разности. И если такое число существует, то вместе с остальными коэффициентами оно даст нам решение.
</p>

<p class="column text">
  Так как теперь в сумме степеней будет на одно слагаемое меньше, то в качестве бонуса мы также получим более высокое значение переменной <span class="codetext">hiFactor</span>. Максимальное значение старшего коэффициента (для уравнения 4.1.3) увеличится с 49,796 до 55,108!
</p>

<div class="column">
  <script src="https://gist.github.com/aloncat/a188e76357c26aedbcb5cf907e16cb51.js?file=fn-v4-changes-a.cpp"></script>
</div>

<p class="column text">
  Так как массив степеней упорядочен по возрастанию, мы можем использовать бинарный поиск, чтобы найти число по его степени. По сложности это и будет примерно соответствовать <span class="codetext">std::map::find()</span>. И так как коэффициенты решения должны располагаться в невозрастающем порядке, то искомое значение не будет превышать значения предпоследнего коэффициента, что сделает поиск ещё быстрее. И теперь начало основного цикла нашего алгоритма будет выглядеть следующим образом:
</p>

<div class="column">
  <script src="https://gist.github.com/aloncat/a188e76357c26aedbcb5cf907e16cb51.js?file=fn-v4-changes-b.cpp"></script>
</div>

<p class="column text">
  Новый оптимизированный алгоритм работает даже лучше, чем я ожидал. До значения старшего коэффициента, равного 700, на этот раз программа добралась всего за 101 секунду! Это примерно в 1.49 раза быстрее, чем исходный вариант с <span class="codetext">std::map</span> (который закончил работу даже раньше, ещё на значении 630)! И более, чем в 6 раз быстрее варианта, предшествующего оптимизации!
</p>

<div class="column divider">&bull; &bull; &bull;</div>

<p class="column text">
  Перед тем, как двигаться дальше, я сделал небольшой рефакторинг: вынес вывод прогресса в отдельную функцию <span class="codetext">UpdateProgress()</span>, чтобы сократить тело главного цикла и сделать код понятнее. Изменение незначительное, поэтому останавливаться на нём буду.
</p>

<p class="column text">
  Далее нам следует разделить основной цикл, в котором сейчас перебираются все коэффициенты, на два цикла: внешний, в котором мы будем инкрементировать старший коэффициент, и внутренний, в котором мы будем перебирать коэффициенты правой части уравнения.
</p>

<p class="column text">
  Не стоит также вычислять всю сумму в каждой итерации. Так как в итерации мы обычно меняем только предпоследний коэффициент правой части, лучше будет считать сумму один раз перед началом внутреннего цикла и корректировать её в конце цикла после изменения значения коэффициента.
</p>

<p class="column text">
  После перечисленных изменений время работы программы (для уравнения 4.1.4, до <span class="codetext">k[0]&nbsp;==&nbsp;700</span>) сократилось до 91 секунды, то есть ещё в 1.11 раза. Совсем немного, но тоже неплохо. Вот так теперь выглядит начало цикла:
</p>

<div class="column">
  <script src="https://gist.github.com/aloncat/a188e76357c26aedbcb5cf907e16cb51.js?file=fn-v5-changes-a.cpp"></script>
</div>

<p class="column text">
  А так выглядит его конец:
</p>

<div class="column">
  <script src="https://gist.github.com/aloncat/a188e76357c26aedbcb5cf907e16cb51.js?file=fn-v5-changes-b.cpp"></script>
</div>

<div class="column divider">&bull; &bull; &bull;</div>

<p class="column text">
  Сейчас для каждого следующего коэффициента мы перебираем все значения, начиная от 1 и до значения коэффициента, расположенного левее. Проблема в том, что среди них есть огромное количество значений, при которых решений быть не может.
</p>

<p class="column text">
  Например, когда в левой части значение коэффициента равно 100, нет смысла начинать перебор с единицы: для первого коэффициента правой части все значения, меньшие 71, не имеют смысла, так как если даже все остальные коэффициенты будут равны 70, то сумма их степеней всё равно окажется меньше значения левой части!
</p>

<p class="column text">
  Также возникает ситуация, когда сумма степеней коэффициентов правой части уже превышает значение левой. В таких случаях перебор нужно прерывать и переходить к следующему значению коэффициента. Именно это мы сейчас и сделаем, изменив всего 2 строчки в конце внутреннего цикла:
</p>

<div class="column">
  <script src="https://gist.github.com/aloncat/a188e76357c26aedbcb5cf907e16cb51.js?file=fn-v6-changes.cpp"></script>
</div>

<p class="column text">
  Эта очень простая оптимизация сократила время работы программы до 62.2 секунды, или ещё в 1.46 раза!
</p>

<div class="column divider">&bull; &bull; &bull;</div>

<p class="column text">
  Далее я снова сделал небольшой рефакторинг. Вынес открытие файла в отдельную функцию <span class="codetext">OpenLogFile()</span>. А проверку и вывод решения &mdash; в функцию <span class="codetext">OnSolutionFound()</span>. Вот листинг этой функции:
</p>

<div class="column">
  <script src="https://gist.github.com/aloncat/a188e76357c26aedbcb5cf907e16cb51.js?file=on-solution-found.cpp"></script>
</div>

<p class="column text">
  Теперь главный цикл функции <span class="codetext">SearchForFactors()</span> стал ещё компактнее:
</p>

<div class="column">
  <script src="https://gist.github.com/aloncat/a188e76357c26aedbcb5cf907e16cb51.js?file=fn-v7-changes.cpp"></script>
</div>

<p class="column text">
  Вот <a href="https://github.com/aloncat/ilwn/blob/93e27002d23d64f5baf14e07bde02537bbe329cd/source/lab/diophantine.cpp" target="_blank">здесь находится</a> исходный файл со всеми сделанными изменениями.
</p>

<p class="column text">
  И перед тем, как продолжить оптимизацию алгоритма, мне бы хотелось кое-что ещё изменить в выводе программы. Речь идёт о том, как выглядят одинаковые коэффициенты правой части уравнения. Вот, например, что сейчас выдаёт программа для уравнения вида 4.1.6:
</p>

<div class="column">
  <pre class="output">Searching for factors (4.1.6)
Factor limit is set to 43826
Solution found: 3=2+2+2+2+2+1
Solution found: 7=6+4+4+4+4+3
Solution found: 9=7+6+6+6+4+2
Solution found: 9=8+7+2+2+2+2
Solution found: 13=12+8+7+6+2+2
Solution found: 17=14+14+8+6+6+1</pre>
</div>

<p class="column text">
  Идея заключается в объединении одинаковых коэффициентов и записи их в виде <i>...+n*k+...</i>, где n &mdash; количество повторений, а k &mdash; значение коэффициента. Так, первое решение из вывода, показанного выше, можно будет записать как 3=5*2+1, а второе &mdash; как 7=6+4*4+3. Это позволит сделать вывод решений более компактным для уравнений с большим количеством коэффициентов в правой части. Внесём необходимые изменения в функцию <span class="codetext">OnSolutionFound()</span>:
</p>

<div class="column">
  <script src="https://gist.github.com/aloncat/a188e76357c26aedbcb5cf907e16cb51.js?file=on-solution-found-v2.cpp"></script>
</div>

<p class="column text">
  И теперь тот же самый вывод выглядит вот так:
</p>

<div class="column">
  <pre class="output">Searching for factors (4.1.6)
Factor limit is set to 43826
Solution found: 3=5*2+1
Solution found: 7=6+4*4+3
Solution found: 9=7+3*6+4+2
Solution found: 9=8+7+4*2
Solution found: 13=12+8+7+6+2*2
Solution found: 17=2*14+8+2*6+1</pre>
</div>

<div class="column divider">&bull; &bull; &bull;</div>

<p class="column text">
  Снова возвращаемся к оптимизации. Мы уже пропускаем значения коэффициентов, которые больше, чем необходимо. Пора сделать то же самое для значений, которые меньше. Как я говорил выше, нет смысла всегда начинать перебор с единицы. Когда мы обнаруживаем, что коэффициент достиг верхнего предела своего значения, мы должны увеличить на 1 коэффициент слева от него, и начать перебор &laquo;сначала&raquo;.
</p>

<p class="column text">
  Каждый раз это начальное значение будет разным: оно зависит от суммы степеней предыдущих коэффициентов. И так как эту сумму мы знаем, то несложно вычислить, с какого значения нужно начать перебор, чтобы не проверять те решения, при которых сумма в правой части всегда будет меньше, чем необходимо. Это должно быть минимально возможное значение, при котором сумма степеней коэффициентов, стоящих слева, и степеней максимальных значений коэффициентов правее, включая искомый, будет превышать значение левой части уравнения.
</p>

<p class="column text">
  Чтобы это реализовать, нам понадобится считать сумму степеней всех коэффициентов правой части. Но одно сделанное недавно изменение будет мешать. Помните, что мы сделали, когда перестали учитывать в сумме правой части значение степени последнего коэффициента? Мы стали при инициализации массива степеней передеавать в функцию <span class="codetext">CalcPowers()</span> значение <span class="codetext">count &mdash; 1</span> вместо <span class="codetext">count</span>. Вот это изменение придётся откатить, снова понизив максимальное значение старшего коэффициента (то есть переменной <span class="codetext">maxFactor</span>).
</p>

<p class="column text">
  Начало внешнего цикла немного изменилось. Теперь мы быстро пропускаем малые значения первого коэффициента правой части, начиная во внутреннем цикле сразу с нужного значения:
</p>

<div class="column">
  <script src="https://gist.github.com/aloncat/a188e76357c26aedbcb5cf907e16cb51.js?file=fn-v8-changes-a.cpp"></script>
</div>

<p class="column text">
  В конце внутреннего цикла, где мы выбирали следующий набор, измения будут более существенные. Добавим новую переменную <span class="codetext">idx</span> и проинициализируем её нолём. В случае, когда коэффициент будет сброшен в единицу, мы запомним индекс самого левого сброшенного коэффициента. Выйдя из цикла инкремента коэффициентов, мы проверим значение <span class="codetext">idx</span> и если оно будет отлично от 0, то мы вычислим &laquo;нужные&raquo; значения всех сброшенных коэффициентов.
</p>

<p class="column text">
  Чтобы найти минимальное значение коэффициента, большее 1, такое, что будет возможно решение, мы можем просто увеличивать значение в цикле на 1 и каждый раз проверять сумму. Но можно поступить оптимальнее: прибавлять в каждой итерации не 1, а половину значения предыдущего коэффициента, уменьшая это приращение вдвое каждую итерацию.
</p>

<p class="column text">
  Приведу пример. Пусть у нас уравнение 4-й степени и 4 коэффициента в его правой части. И только что был обнулён второй. Нам нужно подобрать начальное значение для этого коэффициента. Положим, что значение коэффициента в левой части равно 300, а значение первого коэффициента в правой &mdash; 240. Тогда минимальное значение, удовлетворяющее условию должно быть равно 200.
</p>

<p class="column text">
  И чтобы его найти, мы последовательно проверим значения 1+120 (мало, принимаем), 121+60 (мало), 181+30 (много, пропускаем), 181+15 (мало), 196+7 (много), 196+3 (мало), 199+1 (мало). Таким образом, всего за 7 итераций мы увеличили начальное значение коэффициента с единицы до 200, с которого и начнём перебор второго коэффициента. Вот код с изменениями:
</p>

<div class="column">
  <script src="https://gist.github.com/aloncat/a188e76357c26aedbcb5cf907e16cb51.js?file=fn-v8-changes-b.cpp"></script>
</div>

<p class="column text">
  С этой оптимизацией скорость работы программы значительно выросла, так как мы отбросили огромное количество наборов коэффициентов, которые заведомо не могли дать решение. Время работы для уравнения вида 4.1.4 до достижения <span class="codetext">k[0]&nbsp;==&nbsp;700</span> сократилось до 4.65 секунды, то есть примерно в 13.4 раза относительно предыдущего раунда оптимизации.
</p>

<div class="column divider">&bull; &bull; &bull;</div>

<p class="column text">
  Есть ещё один интересный приём. Но сначала вопрос. Что именно, какую операцию больше всего раз (и дольше) мы делаем в программе? На что уходит больше всего времени? Правильный ответ &mdash; поиск (проверка) значения последнего коэффициента в масиве степеней! Именно эта операция выполняется в каждом цикле перебора коэффициентов. Её оптимизация должна дать хорошее ускорение. Поэтому при переходе от последовательного перебора к бинарному поиску в начале статьи мы получили очень сильный эффект.
</p>

<p class="column text">
  Но как можно уменьшить количество итераций цикла для бинарного поиска? ... Никак! Но можно сделать так, чтобы частенько обходиться вообще без него! Секрет здесь в том, что намного чаще искомого значения в массиве нет и поиск напрасен. И если бы можно было сразу понять, что такого значения в массиве нет, мы бы сэкономили кучу времени. И такой способ есть!
</p>

<p class="column text">
  Мы можем заранее вычислить хеши для всех значений в массиве степеней и поместить их в очень компактный массив (размер которого будет сопоставим с размером кеша L1/L2 процессора). Проверка значения в такой хеш-таблице &mdash; это очень быстро. Но так как значений в хеш-таблице меньше, чем возможных значений коэффициентов, то на каждый элемент хеш-таблицы будет приходиться несколько из значений массива степеней. Но это совсем не страшно.
</p>

<p class="column text">
  Таким образом, если мы обнаружим в хеш-таблице хеш нужного значения степени, то это будет означать, что искомое значение коэффициента может существовать и нам нужно выполнить поиск в массиве как обычно. А вот если в хеш-таблице значения не окажется, это будет гарантировать нам то, что искомого значения не существует! Ниже приведён код класса <span class="codetext">HashTable</span>, в котором за проверку значения отвечает функция <span class="codetext">Exists()</span>:
</p>

<div class="column">
  <script src="https://gist.github.com/aloncat/a188e76357c26aedbcb5cf907e16cb51.js?file=hash-table.cpp"></script>
</div>

<p class="column text">
  В начале функции <span class="codetext">SearchForFactors()</span>, сразу после инициализации массива степеней, инициализируем нашу хеш-таблицу:
</p>

<div class="column">
  <script src="https://gist.github.com/aloncat/a188e76357c26aedbcb5cf907e16cb51.js?file=fn-v9-changes-a.cpp"></script>
</div>

<p class="column text">
  Теперь внесём изменения в начало внутреннего цикла. Непосредственно перед поиском исходного числа для <span class="codetext">lastFP</span> (степень последнего коэффициента правой части) добавим проверку хеша:
</p>

<div class="column">
  <script src="https://gist.github.com/aloncat/a188e76357c26aedbcb5cf907e16cb51.js?file=fn-v9-changes-b.cpp"></script>
</div>

<p class="column text">
  Благодаря сделанным изменениям удалось сократить время работы программы ещё сильнее. Для того же уравнения вида 4.1.4 до достижения старшим коэффициентом значения <span class="codetext">k[0]&nbsp;==&nbsp;700</span> теперь требуется всего 0.55 секунды! Таким образом, работа программы стала быстрее в 8.5 раза относительно предыдущего раунда оптимизации. А относительно самого первого (наивного) решения, которому требовалось более 150 секунд, разница составила более 270 раз!
</p>

<p class="column text">
  На этом, пожалуй, я закончу. Вот ссылка на <a href="https://github.com/aloncat/ilwn/blob/5a85bd3ebb0e62981b31b4763b17f94b6470ab17/source/lab/diophantine.cpp" target="_blank">финальный исходный файл</a> программы. Я продолжу дорабатывать её код: добавлю поддержку 128-битной арифметики и многопоточность. Но это произоизойдёт уже за рамками этой статьи. Весь исходный код можно будет найти в <a href="https://github.com/aloncat/ilwn/tree/master/source/eslp" target="_blank">репозитории <b>iLWN</b></a> (проект <b>ESLP</b>).
</p>

<div class="column divider">&bull; &bull; &bull;</div>

<p class="column text">
  В этой статье я не коснулся математических способов сокращения количества перебираемых значений для коэффициентов уравнения, так как эти способы отличаются для разных его видов (вариаций степени и набора коэффициентов). Далее я ещё покажу подобный пример.
</p>

<p class="column text">
  Полученная в результате программа выполняет полный перебор возможных решений, проверяя каждое из них. Я попытался сделать некоторые оптимизации, чтобы исключить проверку тех коэффициентов и их наборов, которые не могут являться решениями. Однако, даже при этом программа работает медленно по сравнению с более оптимальными алгоритмами для отдельных видов уравнения.
</p>

<p class="column text">
  Тем не менее, полученная программа проста и универсальна: её можно использовать для поиска решений любых диофантовых уравнений вида p.1.n. А при необходимости её можно сравнительно легко доработать для решения любых уравнений вида p.m.n.
</p>

<div class="column divider">&bull; &bull; &bull;</div>

<p class="column text">
  В качестве эпилога я покажу, как можно немного сократить количество проверяемых комбинаций для уравнений вида 4.1.3 и 4.1.4. Речь пойдёт о модульной арифметике. И сначала рассмотрим, может ли быть коэффициент в левой части уравнения чётным. Вполне очевидно, что:
</p>

<div class="column mathtext">
  Z&#8287;&#8801;&#8287;0 (mod 2) &emsp;&#8658;&emsp; Z<sup>4</sup>&#8287;&#8801;&#8287;0 (mod 16)
  <div class="ref">(1)</div>
</div>

<p class="column text">
  Также несложно убедиться, что:
</p>

<div class="column mathtext">
  Z&#8287;&#8802;&#8287;0 (mod 2) &emsp;&#8658;&emsp; Z<sup>4</sup>&#8287;&#8801;&#8287;1 (mod 16)
  <div class="ref">(2)</div>
</div>

<p class="column text">
  Рассмотрим диофантово уравнение вида 4.1.3 (для 4.1.4 все рассуждения будут аналогичны):
</p>

<div class="column mathtext">
  z<sup>4</sup>&#8287;=&#8287;a<sup>4</sup>&#8287;+&#8287;b<sup>4</sup>&#8287;+&#8287;c<sup>4</sup>
  <div class="ref">(3)</div>
</div>

<p class="column text">
  Если z чётно, а также чётны a, b, и c, то очевидно, что такое решение не примитивно, так как каждый коэффициент делится на 2 без остатка. Так как нас не итересуют подобные решения, то предположим, что z &mdash; чётное, и хотя бы один из коэффициентов правой части нечётный. В таком случае, по свойству сравнений, учитывая (2), мы получим, что:
</p>

<div class="column mathtext">
  a<sup>4</sup>&#8287;+&#8287;b<sup>4</sup>&#8287;+&#8287;c<sup>4</sup>&#8287;&#8801;&#8287;1, 2, или 3 (mod 16)
  <div class="ref">(4)</div>
</div>

<p class="column text">
  Так как z чётно, то выполняется (1), следовательно, при таких условиях левая часть уравнения (3) не будет равна правой, а значит такой набор коэффициентов решением не будет. Таким образом, можно сделать вывод, что при чётных значениях z непримитивных решений не существует. Это означает, что перебирая все возможные наборы коэффициентов, мы можем пропустить те из них, в которых старший коэффициент чётный. И проверять только те наборы, в которых он нечётный. Это должно сократить количество всех проверяемых комбинаций вдвое.
</p>

<p class="column text">
  Рассмотрим теперь делимость старшего коэффициента на 5. Аналогично (1) и (2), мы можем легко убедиться, что:
</p>

<div class="column mathtext">
  Z&#8287;&#8801;&#8287;0 (mod 5) &emsp;&#8658;&emsp; Z<sup>4</sup>&#8287;&#8801;&#8287;0 (mod 5)
  <div class="ref">(5)</div>
</div>

<div class="column mathtext">
  Z&#8287;&#8802;&#8287;0 (mod 5) &emsp;&#8658;&emsp; Z<sup>4</sup>&#8287;&#8801;&#8287;1 (mod 5)
  <div class="ref">(6)</div>
</div>

<p class="column text">
  Выполняя рассуждения аналогичные тем, что мы делали для делимости на 2, мы можем прийти к следующему выводу. Если (z, a, b, c) является непримитивным решением уравнения (3), то:
</p>

<div class="column mathtext">
  a<sup>4</sup>&#8287;+&#8287;b<sup>4</sup>&#8287;+&#8287;c<sup>4</sup>&#8287;&#8802;&#8287;0 (mod 5)
  <div class="ref">(7)</div>
</div>

<p class="column text">
  Утверждение (7) справедливо для уравнений вида 4.1.3 и 4.1.4 (но не для 4.1.5 и других). И означает, что если коэффициент в левой части (z) делится на 5 без остатка, то не существует таких целых чисел a, b и c, которые могли бы дать непримитивное решение. Поэтому при переборе мы можем пропускать не только чётные значения старшего коэффициента, но также и те, что кратны 5.
</p>

<!-- Navigation links -->
<script>insertBottomLinks()</script>

<!-- Footer -->
<div id="pageFooter" data-lang="ru" data-url-path="/blog/equal-sums-of-like-powers.html"></div>

<!-- Links to other posts -->
<script>
  function setPostLinks() {
	setPrevBlogPostUrl("");
	setNextBlogPostUrl("");
  }
</script>

</body>
</html>
